public static Document addElementFromDataTable(
        Document doc,
        Node parent,
        String namespace,
        String elementName,
        Map<String, String> elementAttrs,
        DataTable table
) {
    List<Map<String, String>> rows = table.asMaps();
    List<ChildElement> children = new ArrayList<>();

    for (Map<String, String> row : rows) {
        String name = row.get("name");
        String text = row.get("text");

        Map<String, String> childAttrs = new HashMap<>();
        for (Map.Entry<String, String> entry : row.entrySet()) {
            if (!entry.getKey().equals("name") && !entry.getKey().equals("text")
                    && entry.getValue() != null && !entry.getValue().isBlank()) {
                childAttrs.put(entry.getKey(), entry.getValue());
            }
        }

        children.add(new ChildElement(name, text, childAttrs.isEmpty() ? null : childAttrs));
    }

    XmlUtil.addElementWithNamespaceAndChildren(
            doc, parent, namespace, elementName,
            (elementAttrs == null || elementAttrs.isEmpty()) ? null : elementAttrs,
            children
    );

    return doc;
}


public static Element addElementWithOptionalNamespaceAndChildren(
        Document doc,
        Node parent,
        String qualifiedTagName, // e.g., "po:DeliveryDetails"
        Map<String, String> elementAttributes,
        List<ChildElement> children // each with name, text, and optional attributes
) {
    String prefix = qualifiedTagName.contains(":") ? qualifiedTagName.split(":")[0] : null;
    String namespaceUri = null;

    // Try to find existing xmlns:prefix in parent chain
    if (prefix != null) {
        namespaceUri = findNamespaceUri(parent, prefix);
    }

    Element element = namespaceUri != null
            ? doc.createElementNS(namespaceUri, qualifiedTagName)
            : doc.createElement(qualifiedTagName);

    // Auto-declare xmlns:prefix on this element if not already present
    if (prefix != null && namespaceUri != null && !element.hasAttribute("xmlns:" + prefix)) {
        element.setAttribute("xmlns:" + prefix, namespaceUri);
    }

    // Add attributes
    if (elementAttributes != null) {
        for (Map.Entry<String, String> attr : elementAttributes.entrySet()) {
            element.setAttribute(attr.getKey(), attr.getValue());
        }
    }

    // Add children
    if (children != null) {
        for (ChildElement child : children) {
            String childQualifiedName = child.qualifiedName;
            if (prefix != null && !childQualifiedName.contains(":")) {
                childQualifiedName = prefix + ":" + childQualifiedName;
            }

            Element childElement = namespaceUri != null
                    ? doc.createElementNS(namespaceUri, childQualifiedName)
                    : doc.createElement(childQualifiedName);

            childElement.setTextContent(child.text);

            if (child.attributes != null) {
                for (Map.Entry<String, String> attr : child.attributes.entrySet()) {
                    childElement.setAttribute(attr.getKey(), attr.getValue());
                }
            }

            element.appendChild(childElement);
        }
    }

    parent.appendChild(element);
    return element;
}


private static String findNamespaceUri(Node node, String prefix) {
    while (node != null && node.getNodeType() == Node.ELEMENT_NODE) {
        Element el = (Element) node;
        String attrName = "xmlns:" + prefix;
        if (el.hasAttribute(attrName)) {
            return el.getAttribute(attrName);
        }
        node = node.getParentNode();
    }
    return null; // fallback
}

@And("it has child elements")
public void itHasChildElements(DataTable table) {
    Document doc = XmlUtil.addElementFromDataTable(
        (Document) scenarioContext.get("doc"),
        (Node) scenarioContext.get("parentNode"),
        (String) scenarioContext.get("namespace"),
        (String) scenarioContext.get("elementName"),
        (Map<String, String>) scenarioContext.get("elementAttrs"),
        table
    );

    scenarioContext.put("requestXml", XmlUtil.toString(doc)); // only here!
}


public static Document addElementFromDataTableOptionalNamespace(
        Document doc,
        Node parent,
        String qualifiedElementName,
        Map<String, String> elementAttrs,
        DataTable table
) {
    List<Map<String, String>> rows = table.asMaps();
    List<ChildElement> children = new ArrayList<>();

    for (Map<String, String> row : rows) {
        String name = row.get("name");
        String text = row.get("text");

        Map<String, String> childAttrs = new HashMap<>();
        for (Map.Entry<String, String> entry : row.entrySet()) {
            if (!entry.getKey().equals("name") && !entry.getKey().equals("text")
                    && entry.getValue() != null && !entry.getValue().isBlank()) {
                childAttrs.put(entry.getKey(), entry.getValue());
            }
        }

        children.add(new ChildElement(name, text, childAttrs.isEmpty() ? null : childAttrs));
    }

    XmlUtil.addElementWithOptionalNamespaceAndChildren(
            doc,
            parent,
            qualifiedElementName,
            (elementAttrs == null || elementAttrs.isEmpty()) ? null : elementAttrs,
            children
    );

    return doc;
}





 public static Node getNodeByXPath(Document doc, String xpathExpression) {
        try {
            return (Node) xPath.evaluate(xpathExpression, doc, XPathConstants.NODE);
        } catch (XPathExpressionException e) {
            throw new RuntimeException("Invalid XPath: " + xpathExpression, e);
        }
    }

    // Optional: also get NodeList
    public static Node[] getNodesByXPath(Document doc, String xpathExpression) {
        try {
            var nodeList = (org.w3c.dom.NodeList) xPath.evaluate(xpathExpression, doc, XPathConstants.NODESET);
            Node[] result = new Node[nodeList.getLength()];
            for (int i = 0; i < nodeList.getLength(); i++) {
                result[i] = nodeList.item(i);
            }
            return result;
        } catch (XPathExpressionException e) {
            throw new RuntimeException("Invalid XPath: " + xpathExpression, e);
        }
    }

import javax.xml.namespace.NamespaceContext;
import java.util.Iterator;
import java.util.Map;

public class SimpleNamespaceContext implements NamespaceContext {

    private final Map<String, String> prefixMap;

    public SimpleNamespaceContext(Map<String, String> prefixMap) {
        this.prefixMap = prefixMap;
    }

    @Override
    public String getNamespaceURI(String prefix) {
        return prefixMap.getOrDefault(prefix, "");
    }

    @Override
    public String getPrefix(String namespaceURI) {
        for (Map.Entry<String, String> entry : prefixMap.entrySet()) {
            if (entry.getValue().equals(namespaceURI)) {
                return entry.getKey();
            }
        }
        return null;
    }

    @Override
    public Iterator<String> getPrefixes(String namespaceURI) {
        return prefixMap.keySet().iterator();
    }
}

public class SimpleNamespaceContext implements NamespaceContext {

    private final Map<String, String> prefixMap;

    public SimpleNamespaceContext(Map<String, String> prefixMap) {
        this.prefixMap = prefixMap;
    }

    @Override
    public String getNamespaceURI(String prefix) {
        return prefixMap.getOrDefault(prefix, XMLConstants.NULL_NS_URI);
    }

    @Override
    public String getPrefix(String namespaceURI) {
        return prefixMap.entrySet().stream()
            .filter(e -> e.getValue().equals(namespaceURI))
            .map(Map.Entry::getKey)
            .findFirst()
            .orElse(null);
    }

    @Override
    public Iterator<String> getPrefixes(String namespaceURI) {
        return prefixMap.keySet().iterator();
    }
}

public static Node getSingleNodeByXPath(Document doc, String xpathExpr, Map<String, String> namespaces) {
    List<Node> nodes = getNodeListByXPath(doc, xpathExpr, namespaces);
    if (nodes.size() != 1) {
        throw new IllegalStateException("Expected exactly one node but found: " + nodes.size());
    }
    return nodes.get(0);
}


public static List<Element> getChildNodesByXPath(Document doc, String parentXPath, String childLocalName, Map<String, String> namespaces) throws XPathExpressionException {
    XPath xpath = XPathFactory.newInstance().newXPath();
    xpath.setNamespaceContext(new SimpleNamespaceContext(namespaces));

    Node parent = (Node) xpath.evaluate(parentXPath, doc, XPathConstants.NODE);
    if (parent == null) return List.of();

    List<Element> results = new ArrayList<>();
    NodeList children = parent.getChildNodes();
    for (int i = 0; i < children.getLength(); i++) {
        Node node = children.item(i);
        if (node.getNodeType() == Node.ELEMENT_NODE &&
            (childLocalName == null || node.getLocalName().equals(childLocalName))) {
            results.add((Element) node);
        }
    }
    return results;
}

public static List<Node> getNodeListByXPath(Document doc, String xpathExpr, Map<String, String> namespaces) {
    try {
        XPath xpath = XPathFactory.newInstance().newXPath();
        if (namespaces != null && !namespaces.isEmpty()) {
            xpath.setNamespaceContext(new SimpleNamespaceContext(namespaces));
        }

        NodeList nodes = (NodeList) xpath.evaluate(xpathExpr, doc, XPathConstants.NODESET);
        List<Node> nodeList = new ArrayList<>();
        for (int i = 0; i < nodes.getLength(); i++) {
            nodeList.add(nodes.item(i));
        }
        return nodeList;

    } catch (XPathExpressionException e) {
        throw new RuntimeException("XPath evaluation failed: " + xpathExpr, e);
    }
}




------------------

public static List<Element> getChildElements(Node parent) {
    List<Element> elements = new ArrayList<>();
    NodeList children = parent.getChildNodes();
    for (int i = 0; i < children.getLength(); i++) {
        Node node = children.item(i);
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            elements.add((Element) node);
        }
    }
    return elements;
}

public static List<Element> getChildElements(Node parent, String localName) {
    List<Element> elements = new ArrayList<>();
    NodeList children = parent.getChildNodes();
    for (int i = 0; i < children.getLength(); i++) {
        Node node = children.item(i);
        if (node.getNodeType() == Node.ELEMENT_NODE && node.getLocalName().equals(localName)) {
            elements.add((Element) node);
        }
    }
    return elements;
}
